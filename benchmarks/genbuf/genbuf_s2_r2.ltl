INPUT:s2b_req0 
INPUT:s2b_req1 
INPUT:r2b_ack0
INPUT:r2b_ack1
OUTPUT:b2s_ack0
OUTPUT:b2s_ack1
OUTPUT:b2r_req0
OUTPUT:b2r_req1
PROPERTY:
#Alert! I removed enq, deq, full, empty signals!

# and of
(
(
#safety
(
(!s2b_req0) &&   
(!s2b_req1) &&   
(!r2b_ack0) && 
(!r2b_ack1) && 

G((s2b_req0 && (!b2s_ack0)) -> X(s2b_req0)) &&   
G(b2s_ack0 -> X((!s2b_req0))) && 

G((s2b_req1 && (!b2s_ack1)) -> X(s2b_req1)) &&   
G(b2s_ack1 -> X((!s2b_req1))) && 

G((!b2r_req0) -> X((!r2b_ack0))) &&  
G((!b2r_req1) -> X((!r2b_ack1)))
)
-> 
( 
(!b2s_ack0) &&   
(!b2r_req0) &&    
(!b2r_req1) &&   
(!b2s_ack1) &&   

G( ((!b2s_ack0) && X((!s2b_req0))) -> X((!b2s_ack0)) ) &&   
G( ((!b2s_ack1) && X((!s2b_req1))) -> X((!b2s_ack1)) ) &&   

#two_indexed
#mutual_exclusion_of_ack
G((!b2s_ack0) || (!b2s_ack1)) &&  

G(r2b_ack0 -> X((!b2r_req0))) &&   
G(r2b_ack1 -> X((!b2r_req1))) &&   

G((b2r_req1 && (!r2b_ack1)) -> X(b2r_req1)) &&   
G((b2r_req0 && (!r2b_ack0)) -> X(b2r_req0)) &&   

#two_indexed
#mutual_exclusion_of_req_to_receivers (* strange, I thought that is subsumed! *)
G(((!b2r_req0)) || ((!b2r_req1)) ) &&  

G( ((!s2b_req0) && X(s2b_req0)) -> X((!b2s_ack0))) &&
G( ((!s2b_req1) && X(s2b_req1)) -> X((!b2s_ack1)) )
)
)



&&



(
#liveness
(  
(!s2b_req0) &&   
(!s2b_req1) &&   
(!r2b_ack0) && 
(!r2b_ack1) && 

G((s2b_req0 && (!b2s_ack0)) -> X(s2b_req0)) &&   
G(b2s_ack0 -> X((!s2b_req0))) && 

G((s2b_req1 && (!b2s_ack1)) -> X(s2b_req1)) &&   
G(b2s_ack1 -> X((!s2b_req1))) && 

G((!b2r_req0) -> X((!r2b_ack0))) &&  
G((!b2r_req1) -> X((!r2b_ack1))) &&

G(b2r_req0 -> X(F(r2b_ack0))) &&   
G(b2r_req1 -> X(F(r2b_ack1))) 
)

->

(
# (* Round-Robin requests of readers (token rings!) *)
# (* automatic mutual exclusion  *)
# (* always two receivers only *)

#two_indexed (*round-robin and mutual exclusion*)
G((b2r_req0 && X((!b2r_req0))) -> X( (!b2r_req0) U ((!b2r_req0) && b2r_req1))) &&  
G((b2r_req1 && X((!b2r_req1))) -> X( (!b2r_req1) U ((!b2r_req1) && b2r_req0))) &&  

# (* every sender's request should finally be acknowledged *)
G( ((!s2b_req0) && X(s2b_req0)) -> X(X(F(b2s_ack0))) ) &&   
G( ((!s2b_req1) && X(s2b_req1)) -> X(X(F(b2s_ack1))) ) &&   

#two_indexed (* If there are requests from senders then at least one receiver should be activated *)
# (*for me it seems strange, why not to use 'empty' signal and say: G(!empty -> F((b2r_req0 || b2r_req1))) *)
G((s2b_req0 || s2b_req1) -> X(F(b2r_req0 || b2r_req1)))
)
)

)