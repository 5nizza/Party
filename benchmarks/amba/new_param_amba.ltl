#TODO: check that active_i variables inserted where necessary -- to achieve this use cutoffs bigger than 2

[INPUT_VARIABLES]
#variable 'active' is always present

#TODO: not used
sready;

mbusreq; 

mlocked;
# if low => one tick request 
# TODO: extend later to support INCR (really INCR) signal
mburst;


[OUTPUT_VARIABLES]
# TODO: check which other variables to add
#TODO: not used
#amaster_i;

agrant;

#auxiliary variables to ease to make specification readable
#they are like bits of the memory: the actual output may be mealy-dependent on them
auxonegrant;
auxlockedburstgrant;


[ASSUMPTIONS]
# TODO: doesn't look fair? -- we tailored the spec to Token Rings

# i don't think we need this: "Every master lowers request at some point"
# it is handled via token in assumptions
# Forall(i) 
# GF(mbusreq_i=0);

# "Every slave raises 'sready' at some point"
Forall(i) 
G(F(sready_i=1));

## TODO: until we handle more types of requests
#Forall(i)
#G (mburst_i=0 * mlocked_i=0 + 
#   mburst_i=1 * mlocked_i=1);


[GUARANTEES]
## initially
Forall(i) 
auxonegrant_i=0 * 
auxlockedburstgrant_i=0 * 
agrant_i=0;


## Mutual exclusion in token rings: "grant only when possess the token"
Forall(i)
G (agrant_i=1 -> tok_i=1);

## Setting aux variables 
# Note: later updates rewrite aux values
# Note: when granting ignore requests
Forall(i) 
G ( active_i=1 * mbusreq_i=1 * mlocked_i=0 * mburst_i=0 * X(agrant_i=0) -> 
    X (auxonegrant_i=1 * auxlockedburstgrant_i=0) # can use X due to active_i 
);

Forall(i) 
G ( active_i=1 * mbusreq_i=1 * mlocked_i=1 * mburst_i=1 * X(agrant_i=0) -> 
    X (auxonegrant_i=0 * auxlockedburstgrant_i=1) 
);

# no spurious aux risings
Forall(i)
!F ( (active_i=1 * auxonegrant_i=0 * mbusreq_i=0) *   # we need to ensure at least on tick with zero values
    ((auxonegrant_i=0 * mbusreq_i=0) U (auxonegrant_i=1)) );

Forall(i)
!F ( (active_i=1 * auxlockedburstgrant_i=0 * mbusreq_i=0) * 
     ((auxlockedburstgrant_i=0 * mbusreq_i=0) U (auxlockedburstgrant_i=1) ));


## Granting based on aux variables, and clearing aux
# TODO: hm, we lose ticks here
Forall(i)
G (auxonegrant_i=1 * tok_i=1 -> 
    X (agrant_i=1 * auxonegrant_i=0 * 
      ((agrant_i=1 * auxonegrant_i=0) U (sready_i=1 * X(agrant_i=0)))
      )
);

# Forall(i)
# G(F(mbusreq_i=1 * mlocked_i=1 * mburst_i=1 * agrant_i=0)) -> 
#   G(F(auxlockedburstgrant_i=1));

# Forall(i)
# G(F(mbusreq_i=1 * mlocked_i=1 * mburst_i=1 * agrant_i=0)) -> 
#   G(F(auxlockedburstgrant_i=0));

# Forall(i)
# G (auxonegrant_i=1 * tok_i=1 -> 
#     (auxonegrant_i=1 * tok_i=1) U 
#       ( (agrant_i=1 * auxonegrant_i=0) U 
#         (agrant_i=0))
# );
 
# );

# welcome to the hell: "every burst4 request is granted for times, 'granted' means agrant_i=1 * sready_i=1"
Forall(i) 
G ( auxlockedburstgrant_i=1 * tok_i=1 ->
    X(agrant_i=1 * auxlockedburstgrant_i=0 * 
      (agrant_i=1 * auxlockedburstgrant_i=0) 
      U 
      (sready_i=1 * 
        X(agrant_i=1 * auxlockedburstgrant_i=0 * 
          (agrant_i=1 * auxlockedburstgrant_i=0) 
          U 
          (sready_i=1 * 
            X(agrant_i=1 * auxlockedburstgrant_i=0 * 
              (agrant_i=1 * auxlockedburstgrant_i=0) 
              U 
              (sready_i=1 *
                X(agrant_i=1 * auxlockedburstgrant_i=0 * 
                  (agrant_i=1 * auxlockedburstgrant_i=0) 
                  U 
                  (sready_i=1 * X(agrant_i=0))
                 )
              )
             )
          )
         )
      )
     )
  );

# Forall(i) 
# G ( auxlockedburstgrant_i=1 * tok_i=1 ->
#     X(agrant_i=1 * auxlockedburstgrant_i=0) *
#     X(X(agrant_i=1 * auxlockedburstgrant_i=0)) * 
#     X(X(X(agrant_i=1 * auxlockedburstgrant_i=0))) * 
#     X(X(X(X(agrant_i=0)))));

# no spurious grants
Forall(i)
!F( (auxlockedburstgrant_i=0 * auxonegrant_i=0 * agrant_i=0) * 
    ((auxlockedburstgrant_i=0 * auxonegrant_i=0 * agrant_i=0) 
      U 
     (auxlockedburstgrant_i=0 * auxonegrant_i=0 * agrant_i=1)
    )
);




